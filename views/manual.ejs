<% 
    pageTitle = "Manual"
%>
<% include ./partials/head %>
        
        <p>This page covers using XMPP-FTW from the browser. You may also 
        want to check out the <a href="/demo" title="XMPP-FTW Demo">demo</a> and 
        the <del title="deprecated"><a href="/chat" title="XMPP-FTW Chat client">chat client</a></del>.</p>
        
        <div id="toc"></div>
        
        <h2>Colour conventions</h2>
        
        <p>These colour conventions are also carried over into the <a href="/demo" title="XMPP-FTW demo client">demo client</a>.<p>
        
        <div class="example-out">Outgoing message</div>
        <div class="example-in">Incoming message</div>
        <div class="example-data">Example data</div>
        
        <h2>JIDs</h2>
        
        <p>JIDs are always sent as an object as follows:</p>
        
        <pre class="example">
        { 
            "user": "lloyd",
            "domain": "evilprofessor.co.uk",
            "resource": "laptop"
        }
        </pre>
        
        <h2>Errors</h2>
        
        <p>Errors are delivered in the following form:</p>
        
        <pre class="example in" message="xmpp.error">
        {
            type: "auth",
         /* condition: "forbidden", */
         /* description: "Only owners can configure rooms" */
        }
        </pre>
        
        <h3>Client errors</h3>

        <p>Client errors follow a similar format to standard XMPP error responses. An example error looks like this:</p>

        <pre class="example in" message="xmpp.error.client">
        {
            type: "modify",
            condition: "client-error",
            description: "Missing JID parameter",
            request: { message: "Hello you!" }
        }
        </pre>

        <p>If the request included a callback this will be sent back as the 
        first argument (i.e. '<em>error</em>' variable), otherwise the 
        message will come back as a <strong>xmpp.error.client</strong> event.
        </p>

        <p><strong>Note:</strong> use of '<em>bad-request</em>' was avoided 
        to ensure that a client → XMPP-FTW was discernible from a pure 
        client → XMPP error.</p>

        <h2>Data Forms</h2>
        
        <p>Data forms get their own special page, see <a href="/data-forms">XEP-0040</a>.</p>
         
        <h2>Authentication</h2>
 
        <h3>Login</h3>
        
        <pre class="out" message="xmpp.login">
        socket.emit(
             'xmpp.login',
             { 
                 "jid": "test@evilprofessor.co.uk",
                 "password": "password",
              /* "resource": "xmpp-ftw", */
              /* "host": "127.0.0.1" */
             }
        )
        </pre>
        
        <p>You can also add an optional parameter of <i>resource</i>, if not provided the XMPP 
           server will add this automatically.</p>

        <p>On succesful connection an incoming message comes in as follows:</p>
        
        <pre class="in" message="xmpp.connection">
        socket.on('xmpp.connection', function(data) { 
            console.log(data)
            /*
             * 'online'
             */
        })
        </pre>

        <h4>Anonymous Login</h4>

        <pre class="out" message="xmpp.login.anonymous">
        socket.emit(
            'xmpp.login.anonymous',
            {
                "jid": "anon.evilprofessor.co.uk",
             /* "host": "evilprofessor.co.uk" */
            }
        )
        </pre>

        <h3>Logout</h3>

        <p>Logout is performed with the following call:</p>

        <pre class="out callback" message="xmpp.logout">
        socket.emit(
            'xmpp.logout',
            {},
            function(error, data) { console.log(error, data) }
        )
        </pre>

        <h2>Messaging</h2>

        <h3>Send a message</h3>
        
        <pre class="out" message="xmpp.chat.message"">
        socket.emit(
            'xmpp.chat.message',
            {
                "to": "other@evilprofessor.co.uk",
                "content": "Hello world",
             /* "format": "plain" */
            }
        )
        </pre>

        <p>By setting the value of '<em>format</em>' to '<b>xhtml</b>' the 
        client can invoke 
        <a href="http://xmpp.org/extensions/xep-0071.html" target="_blank">XEP-0071</a> 
        a missing or not-'xhtml' value results in a plain message. A plain 
        text version of XHTML messages are generated by XMPP-FTW and sent 
        alongside XHTML messages.</p>

        <h3>Receive a chat message</h3>

        <pre class="in" message="xmpp.chat.message">
        socket.on('xmpp.chat.message', function(data) {
            console.log(data)
        })
        </pre>

        <p>Example:</p>

        <pre class="example">
        {
            from: 'user2@evilprofessor.co.uk',
            content: 'Hello fine Sir!',
            format: 'plain'
        }        
        </pre>

        <p>The value of '<em>format</em>' will be <b>xhtml</b> for XEP-0071 
        type messages. You will only ever receive a plain text or XHTML 
        message, not both.</p>

        <h2>Presence</h2>

        <h3>Set presence</h3>
        
        <pre class="out" message="xmpp.presence">
        socket.emit(
            'xmpp.presence',
            {
                "show": "online",
                "status": "I'm using xmpp-ftw!",
                "priority": 10,
             /* "to": "megan@evilprofessor.co.uk/mobile" */
            }
        )
        </pre>
        
        <p>Each of the parameters for presence are <i>optional</i>.</p>
        
        <h3>Receive presence</h3>
        <pre class="in" message="xmpp.presence">
        socket.on('xmpp.presence', function(data) { 
            console.log(data); 
            /*
             * { show: 'away', status: "I'm going away", priority: 10 }
             * ...each of these are optional...
             */
        })
        </pre>
        
        <h3>Directed presence</h3>
        
        <pre class="out" message="xmpp.presence.get">
        socket.emit('xmpp.presence.get', { "to": "user@evilprofessor.co.uk" })
        </pre>

        <h3>Go offline</h3>
        
        <pre class="out" message="xmpp.presence.offline">
        socket.emit('xmpp.presence.offline' /*, {} */ )
        </pre>
        
        <h3>Subscribe</h3>
        
        <p>Request to subsribe to a user</p>
        
        <pre class="out" message="xmpp.presence.subscribe">
        socket.emit('xmpp.presence.subscribe', { "to": "user@evilprofessor.co.uk" })
        </pre>
        
        <p>User requests to subscribe to your presence</p>
        <pre class="in" message="xmpp.presence.subscribe">
        socket.on('xmpp.presence.subscribe', function(data) {
            console.log(data)
        })
        </pre>

        <p>Example:</p>

        <pre class="example">
        {
            from: 'user@evilprofessor.co.uk'
            nick: 'Example user' // ...optional...
        }
        </pre>
        
        <p>Respond with subscribed or unsubscribed</p>
        
        <pre class="out" message="xmpp.presence.subscribed">
        socket.emit(
            'xmpp.presence.subscribed',
            {
                "to": "user@evilprofessor.co.uk"
            }
        )
        </pre>
        
        <pre class="out" message="xmpp.presence.unsubscribed">
        socket.emit(
            'xmpp.presence.unsubscribed',
            {
                "to": "user@evilprofessor.co.uk"
            }
        )
        </pre>
        
        <h3>Presence Errors</h3>

        <p>Presence errors are emitting using the 
        '<em>xmpp.presence.error</em>' event name, for example:</p>

        <pre class="in" message="xmpp.presence.error">
        {
            "error":"remote-server-not-found",
            "from":"user@niceprofessor.co.uk"
        }
        </pre>

        <h2>Roster</h2>
        
        <h3>Add user to roster</h3>
        
        <pre class="out callback" message="xmpp.roster.add">
        socket.emit(
            'xmpp.roster.add',
            {
                "jid": "user@evilprofessor.co.uk",
             /* "name": "Example user", */
             /* "group": "example-users" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <h3>Get</h3>
        
        <pre class="out callback" message="xmpp.roster.get">
        socket.emit(
            'xmpp.roster.get',
            {},
            function(error, data) { console.log(error, data) }
        )
        </pre>

        <p>Data returns as array of objects, e.g.</p>

        <pre class="example">
          [ {
               jid: { user: 'user', domain: 'evilprofessor.co.uk' },
               subscription: 'both',
               name: 'Example user',
               group: 'Buddies',
            /* ask = 'subscribe' */
          } ]
        </pre>
        
        <h3>New incoming Roster request</h3>
        
        <pre class="in" message="xmpp.roster.add">
        socket.on('xmpp.roster.add', function(data) {
            console.log(data);
        })
        </pre>
        
        <p>Example:</p>
        <pre class="example">
          {
               jid: { user: 'user', domain: 'evilprofessor.co.uk' },
               subscription: 'both',
               name: 'Example user',
               group: 'Buddies',
            /* ask = 'subscribe' */
          }
        </pre>
        
        <h3>Add a user to a roster group</h3>
        
        <pre class="out" message="xmpp.roster.group">
        socket.emit(
            'xmpp.roster.group',
            {
                "jid": "user@evilprofessor.co.uk",
                "group": "buddies"
            }
        )
        </pre>
        
        <h2>Multi-user chat (MUC) [XEP-0045]</h2>
        
        <h3>Join a room</h3>
        
        <pre class="out" message="xmpp.muc.join">
        socket.emit(
            'xmpp.muc.join',
            {
                "room": "test@conference.evilprofessor.co.uk",
                "nick": "MyNickname"
            }
        )
        </pre>
        
        <h3>Receive room roster</h3>
        
        <pre class="in" message="xmpp.muc.roster">
        socket.on('xmpp.muc.roster', function(data) { console.log(data) })
        </pre>
        
        <p>Example: <i>You may receive many of these messages</i></p>

        <pre class="example">
          {
              room: 'test@conference.evilprofessor.co.uk',
              nick: 'TheirNickname',
           /* affiliation: 'member', */
           /* role: 'member' */
          }
        </pre>
        
        <p>'Affilition' and 'role' tend to be sent on affiliation or role changes.</p>
         
        <h3>Receive a message</h3>
         
        <pre class="in" message="xmpp.muc.message">
        socket.on('xmpp.muc.message', function(data) { console.log(data) })
        </pre>

        <p>Example:</p>

        <pre class="example">
          {
              room: 'test@conference.evilprofessor.co.uk',
              nick: 'TheirNickname',
              content: '&lt;p&gt;Hello &lt;b&gt;world&lt;/b&gt;!&lt;/p&gt;',
              format: 'xhtml',
           /* timestamp: '2012-03-03T20:22:00Z', */
           /* private: false */
          }
        </pre>

        <p>For plain text IMs the '<em>format</em>' attribute will be 
        <b>plain</b>, for XEP-0071 messages it will be <b>xhtml</b>. 
        You will only ever receive a plain or XHTML message, not both.</p>

        <h3>Send a message</h3>
        
        <pre class="out" message="xmpp.muc.message">
        socket.emit(
            'xmpp.muc.message',
            {
                "room": "test@conference.evilprofessor.co.uk",
                "content": "Hello XMPP people!",
             /* "format": "plain" */
             /* "to": "TheirNickname" */
            }
        )
        </pre>

        <p>If 'to' is provided then message becomes a private message.</p>

        <p>If a user wishes to send a formatted message (i.e. XEP-0071) then 
        the value of '<em>format</em>' will be <b>xhtml</b>. XMPP-FTW 
        will generate a plain text version of an XHTML message for 
        sending.</p>
        
        <h3>Leave a room</h3>
        
        <pre class="out" message="xmpp.muc.leave">
        socket.emit(
            'xmpp.muc.leave',
            {
                "room": "test@conference.evilprofessor.co.uk"
            }
        )
        </pre>
        
        <h3>Errors</h3>
        
        <h4>Message Errors</h4>
        
        <pre class="in" message="xmpp.muc.error">
        socket.on('xmpp.muc.error', function(data) { console.log(data) })
        </pre>
        
        <p>Example:</p>
        
        <pre class="example">
          {
              type:  'message',
              error: 'SERVICE-UNAVAILABLE',
              room:  'test@conference.evilprofessor.co.uk',
           /* content: 'Original message content' */
          }
        </pre>
        <p>Code will attempt to grab the extended reason from the 
        '<abbr title="urn:ietf:params:xml:ns:xmpp-stanzas">xmpp-stanzas</abbr>' namespaced 
        element, otherwise it will grab the 'type' attribute from the error tag.</p>

        <h3>Change a user's role</h3>
        
        <pre class="out callback" message="xmpp.muc.role">
        socket.emit(
            'xmpp.muc.role', 
            {
                "room": "test@conference.evilprofessor.co.uk",
                "nick": "TheirNickname",
                "role": "participant"
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        <p>Success will be true and error `null` if all is ok.</p>
        
        <h3>Change a user's affiliation</h3>
        
        <pre class="out callback" message="xmpp.muc.affiliation">
        socket.emit(
            'xmpp.muc.role',
            {
                "room": "test@conference.evilprofessor.co.uk",
                "jid": "user@evilprofessor.co.uk",
                "affiliation": "outcast"
            }
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <h3>Register with a room</h3>
        
        <h4>Get registration information</h4>
        
        <pre class="out callback" message="xmpp.muc.register.info">
        socket.emit(
            'xmpp.muc.register.info',
            {
                "room": "test@conference.evilprofessor.co.uk"
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Example:</p>
        <pre class="example">
        {
            'instructions': 'Reply with the following form',
            'form': {
                title: 'Register with the dev room!',
                instructions: 'Please fill out all required fields',
                fields: [
                    {
                        type: 'hidden',
                        value: '',
                        var: 'muc#register_email',
                        required: true,
                     /* label: 'Email address' */
                    }
                ] 
            }
        }
        </pre>
        
        <h4>Perform registration</h4>
        
        <pre class="out callback" message="xmpp.muc.register">
        socket.emit(
            'xmpp.muc.register',
            {
                "room": "test@conference.evilprofessor.co.uk",
                "form": [ ]
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>

        <h3>Update room configuration</h3>
        
        <h4>Get room configuration</h4>
        
        <pre class="out callback" message="xmpp.muc.room.config.get">
        socket.emit(
            'xmpp.muc.room.config.get',
            { "room": "test@conference.evilprofessor.co.uk" },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Response (can) look like this:</p>
        
        <pre class="example">
        {
            title: "Configuration for test@conference.evilprofessor.co.uk",
            instructions: "Configuration for test@conference.evilprofessor.co.uk",
            form: {
                fields: [
                    { var: "muc#roomconfig_roomname", type: "text-single", required: false, value: "test2", label: "Name" },
                    { var: "muc#roomconfig_persistentroom", type: "boolean", required: false, value: false, label: "Make Room Persistent?" },
                    { var: "muc#roomconfig_roomsecret", type: "text-private", required: false, value: "", label: "Password" },
                    { 
                      var:      "muc#roomconfig_whois",
                      type:     "list-single",
                      required: false,
                      value:    "moderators,
                      label:    "Who May Discover Real JIDs?",
                      options:  [{ label: "Moderators", value: "moderators"}, {label: "Anyone", value: "anyone" }]
                    },
                ],
                title: "Configuration for test@conference.evilprofessor.co.uk",
                instructions: "Configuration for test@conference.evilprofessor.co.uk"
          }
        }
        </pre>

        <h4>Set room configurtion</h4>
        
        <pre class="out callback" message="xmpp.muc.room.config.set">
        socket.emit(
            'xmpp.muc.room.config.set',
            { "room": "test@conference.evilprofessor.co.uk", "form": [ ] },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Form data example:</p>
        <pre class="example">
        {
            room: 'test@conference.evilprofessor.co.uk',
            form: [
                { field: 'muc#roomconfig_membersonly', value: true },
                { field: 'muc#roomconfig_roomname', value: 'Cool XMPP-FTW configured room' },
                { field: 'muc#roomconfig_roomsecret', value: 'abracadabra' }
            ]
        }
        </pre>
        
        <h4>Updates to room configuration</h4>
        
        <pre class="in" message="xmpp.muc.room.config">
        socket.on('xmpp.muc.room.config', function(data) { console.log(data) })
        </pre>
        
        <p>Example confguration updates:</p>
        
        <pre class="example">
        {
            room: test@conference.evilprofessor.co.uk',
            status: [ 100, 110, 104 ]
        }
        </pre>
        
        <h2>Service Discovery (XEP-0030)</h2>
        
        <h3>Discover Entities <em>disco#items</em></h3>
        
        <pre class="out callback" message="xmpp.discover.items">
        socket.emit(
            'xmpp.discover.items',
            { 
                "of": "evilprofessor.co.uk",
             /* "node": "xmpp-ftw updates" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Example response:</p>
        
        <pre class="example">
        [
            { jid: "conference.evilprofessor.co.uk" },
            { jid: "conference.evilprofessor.co.uk", node: "posts" }
        ]
        </pre>

        <h3>Discover Features <em>disco#info</em></h3>
        
        <pre class="out callback" message="xmpp.discover.info">
        socket.emit(
            'xmpp.discover.info',
            { 
                "of": "evilprofessor.co.uk",
             /* "node": "xmpp-ftw updates" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Example response:</p>
        
        <pre class="example">
        [
            { "kind": "identity", "type": "pep", "name": "Prosody", "category": "pubsub" },
            { "kind": "identity", "type": "im", "name": "Prosody", "category": "server" },
            { "kind": "feature", "var": "jabber:iq:register" },
            { "kind": "feature", "var": "vcard-temp" },
            { "kind": "feature", "var": "http://jabber.org/protocol/commands" },
            { "kind": "feature", "var": "jabber:iq:roster" },
            { "kind": "x", "form": [] }
        ]
        </pre>
        
        <h3>Features your client supports</h3>
        
        <p>
        <pre class="in callback" message="xmpp.discover.info">
        socket.on('xmpp.discover.info', function(data, callback) {
            console.log(data)
            callback(/*...see example below...*/)
        })
        </pre>
        
        <p>Example data sent from server:</p>
        
        <pre class="example">
        {
            from: 'lloyd@evilprofessor.co.uk/laptop'
        }
        </pre>
        
        <p>Example reply data (pass as argument to callback):</p>
        
        <pre class="example">
        [
            { "kind": "identity", "type": "pc", "name": "xmpp-ftw", "category": "client" },
            { "kind": "feature", "var": "http://jabber.org/protocol/disco#info" },
            { "kind": "feature", "var": "http://jabber.org/protocol/muc" }
        ]
        </pre>
        
        <h2>Publish-Subscribe (XEP-0060)</h2>
        
        <h3>Create a node</h3>
        
        <pre class="out callback" message="xmpp.pubsub.create">
        socket.emit(
            'xmpp.pubsub.create',
            { 
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
             /* "options": [] */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p><strong>options</strong> should be formatted as a data form 
        in order to add node configuration options at creation time.</p>

        <p>If the node is successfully created `<em>error</em>` will be <b>null</b> and 
        `<em>data</em>` will be <b>true</b>.</p>

        <p>In order to maintain simplicity create-and-configure a node is not currently supported.</p>
        
        <h3>Delete a node</h3>
        
        <pre class="out callback" message="xmpp.pubsub.delete">
        socket.emit(
            'xmpp.pubsub.delete',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
             /* "redirect": "xmpp:pubsub.evilprofessor.co.uk?;node=xmpp-ftw-news" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <h4>Notification of a delete</h4>

        <p>On successful node delete notifications are sent out to all 
        subscribed users.</p>

        <pre class="in" message="xmpp.pubsub.push.delete">
        {
            from: "pubsub.evilprofessor.co.uk",
            node: "xmpp-ftw updates",
         /* redirect: "xmpp:pubsub.evilprofessor.co.uk?;node=xmpp-ftw-news" */
        }
        </pre>
 
        <h3>Subscribe to a node</h3>
        
        <pre class="out callback" message="xmpp.pubsub.subscribe">
        socket.emit(
            'xmpp.pubsub.subscribe',
            {
                "node": "xmpp-ftw updates",
                "to": "pubsub.evilprofessor.co.uk",
             /* "jid": "lloyd@evilprofessor.co.uk/sky" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>If no JID is provided this defaults to the jid used to log in to the 
        server with.</p>
        
        <p>If a subscription is successful then the response will look like the following:</p>
        
        <pre class="example">
        {
            "subscription": "subscribed",
         /* "id" : "subscription-id" */
        }
        </pre>
        
        <p>Alternatively if configuration options are available the `<em>configuration</em>` key will be present. 
        If configuration is required then the `<em>required</em>` sub-key will be <b>true</b>:</p>
        
        <pre class="example">
        {
            "subscription": "unconfigured",
         /* "id": "subscription-id", */
            "configuration": { "required": true }
        }
        </pre>
        
        <h4>Get subscription options</h4>
        
        <pre class="out callback" message="xmpp.pubsub.subscription.config.get">
        socket.emit(
            'xmpp.pubsub.subscription.config.get',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
             /* "jid": "lloyd@evilprofessor.co.uk/sky" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>The response should then contain a 
        <a href="/data-form" title="XEP-0004 Data Forms">data form</a>.</p>
        
        <pre class="example">
        {
            "fields": []
        }
        </pre>
        
        <p>Note: I <strong>can not currently test this</strong> as Prosody 0.9 does not support it. 
        Once supported I will return and test.</p>
        
        <h4>Get default subscription configuration options</h4>

        <pre class="out callback" message="xmpp.pubsub.subscription.config.default">
        socket.emit(
            'xmpp.pubsub.subscription.config.defualt",
            {
                "to": "pubsub.evilprofessor.co.uk",
             /* "node": "xmpp-ftw updates" */
            },
            function(error, data) { console.log(error, data) }
        )

        </pre>

        <p>The response should then contain a
        <a href="/data-form" title="XEP-0004 Data Forms">data form</a>.</p>
 
        <h4>Update subscription options</h4>
        
        <pre class="out callback" message="xmpp.pubsub.subscription.config.set">
        socket.emit(
            'xmpp.pubsub.subscription.config.set',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
                "form": []
             /* "jid": "lloyd@evilprofessor.co.uk/sky" */
        )
        </pre>
        
        <p>See <a href="/data-forms" title="XEP-0004 Data Forms">data forms</a> for details about 
        formatting the outgoing message.</p>
        
        <p>Note: I <strong>can not currently test this</strong> as Prosody 0.9 does not support it. 
        Once supported I will return and test.</p>
       
        <h4>Notification of subscription change</h4>

        <pre class="in" message="xmpp.pubsub.push.subscription">
        {
            from: "pubsub.evilprofessor.co.uk",
            node: "xmpp-ftw updates",
            jid: "megan@evilprofessor.co.uk",
            subscription: "subscribed",
        }      
        </pre> 
        <h3>Unsubscribe from a node</h3>
        
        <pre class="out callback" message="xmpp.pubsub.unsubscribe">
        socket.emit(
            'xmpp.pubsub.unsubscribe',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
             /* "jid": "lloyd@evilprofessor.co.uk/sky", */
             /* "id": "subscription-id" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>If there is no error `<em>data</em>` will simply be <b>true</b>.

        <h3>Publishing</h3>
        
        <p>For information on publishing formats see the page on 
        <a href="/publishing">publishing</a>.</p>
        
        <pre class="out callback" message="xmpp.pubsub.publish">
        socket.emit(
            'xmpp.pubsub.publish',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
                "content": "We can now post to a pub-sub node!",
             /* "id": "1" */
             /* "options": [] */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Providing a '<em>id</em>' attribute will allow you to 
        set post ID# rather than accept a server auto-generated value.</p>

        <p><strong>options</strong> should be formatted as a data form 
        and allows the user to set publish options.</p>
        
        <p>A successful post will result in the following response:</p>
        
        <pre class="example">
        {
            "id": "1"
        }
        </pre>
 
        <h4>Notification of new messages</h4>

        <p>When an item is published to a node that your user is 
        subscribed to then a message will be received with item 
        details.</p>

        <pre class="in" message="xmpp.pubsub.push.item">
        socket.on('xmpp.pubsub.push.item', function(data) {
            console.log(data)
        })        
        </pre>

        <p>The item itself is parsed by `<em>xmpp-ftw-item-parser</em>` 
        and is held in the <strong>item</strong> key if the payload 
        is included.</p>

        <pre class="example">
        {
            from: 'pubsub.evilprofessor.co.uk',
            node: 'weather',
            id:   '201305301825',
         /* entry: ...as parsed by xmpp-ftw-item-parser... */
         /* headers: [ { name: 'SubID', value: '123-abc' } ], */
         /* publisher: "lloyd@evilprofessor.co.uk" */ 
        }
        </pre>

        <h3>Delete an item</h3>
        
        <pre class="out callback" message="xmpp.pubsub.item.delete">
        socket.emit(
            'xmpp.pubsub.item.delete',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
                "id": "1"
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>If deletion is sucessful then `<em>data</em>` will simply be <b>true</b>.</p>
        
        <h4>Item deletion notification</h4>

        <p>If an item is successfully deleted from a node then all 
        subscribers will be notified of this event (configuration 
        dependent).</p>
 
        <pre class="in" message="xmpp.pubsub.push.retract">
        socket.on('xmpp.pubsub.push.retract', function(data) {
            console.log(data)
        })
        </pre>

        <p>With the payload as follows:</p>
 
        <pre class="example">
        {
            node: 'weather',
            from: 'pubsub.evilprofessor.co.uk',
            id: '201305301825'
        }
        </pre>

        <h3>Purge node items</h3>

        <pre class="out callback" message="xmpp.pubsub.purge">
        socket.emit(
            'xmpp.pubsub.purge', 
            {

            }, 
            function(error, data) { console.log(error, data) }
        )
        </pre>

        <p>If purge is sucessful then `<em>data</em>` will be 
        <strong>true</strong>.</p>

        <h4>Notification of purged node</h4>

        <pre class="in" message="xmpp.pubsub.push.purge">
        socket.on('xmpp.pubsub.purge', function(data) { console.log(data) } 
        </pre>
 
        <p>With the payload as follows:</p>

        <pre class="example">
        {
            from: "pubsub.evilprofessor.co.uk",
            node: "xmpp-ftw updates"
        }
        </pre>

        <h3>Node Configuration</h3>
        
        <h4>Get node configuration</h4>
        
        <pre class="out callback" message="xmpp.pubsub.config.get">
        socket.emit(
            'xmpp.pubsub.config.get',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates"
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Note: I <strong>can not currently test this</strong> as Prosody 0.9 does not support it. 
        Once supported I will return and test.</p>
        
        <h4>Set node configuration</h4>
        
        <pre class="out callback" message="xmpp.pubsub.config.set">
        socket.emit(
            'xmpp.pubsub.config.set',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
                "form": []
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>If configuration update is sucessful then `<em>data</em>` will simply be <b>true</b>.</p>
        
        <p>Note: I <strong>can not currently test this</strong> as Prosody 0.9 does not support it. 
        Once supported I will return and test.</p>
       
        <h5>Node configuration update notification</h5>

        <p>On update of a node's configuration then a notification will be 
        sent to all node subscribers.</p>

        <pre class="in" message="xmpp.pubsub.push.configuration">
        socket.on('xmpp.pubsub.push.configuration', function(data) {
            console.log(data)
        })
        </pre> 

        <p>With data looking as follows:</p>

        <pre class="example">
        {
            from: 'pubsub.evilprofessor.co.uk',
            node: 'weather',
         /* configuration: [] */
        }
        </pre>

        <p><strong>configuration</strong> if provided will match the parsing 
        of other <a href="/data-forms" title="Data forms">data forms</a>.</p>

        <h3>Item Retrieval</h3>
        
        <h4>Get item(s)</h4>
        
        <pre class="out callback" message="xmpp.pubsub.retrieve">
        socket.emit(
            'xmpp.pubsub.retrieve',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
             /* "id": "1" ...OR... [ "1", "3", "5" ], */
             /* "max_items": 10 */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>If a single item is required then the '<em>id</em>' attribute should be populated.</p>

        <pre class="example">
        [
            { id: 123, entry: {} }
        ]
        </pre>

        <p>Where <strong>entry</strong> is parsed by 
        `xmpp-ftw-item-parser`.</p>

        <h3>Subscriptions</h3>

        <h4>Get subscriptions</h4>

        <pre class="out callback" message="xmpp.pubsub.subscriptions">
        socket.emit(
            'xmpp.pubsub.subscriptions',
            {
                "to": "pubsub.evilprofessor.co.uk",
             /* "node": "xmpp-ftw updates", */
             /* "owner": true */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Setting <b>owner</b> to true will return information about all 
        subscriptions to that node. This is provided you are the owner of 
        the node, otherwise an error will be returned.</p>

        <p>A successful response will then be as follows:</p>

        <pre class="example">
        [
            { node: "xmpp-ftw updates", jid: "lloyd@evilprofessor.co.uk", subscription: "subscribed" }
            { node: "weather", jid: "lloyd@evilprofessor.co.uk", subscription: "pending", id: "123" }
        ]
        </pre>

        <h3>Affiliations</h3>
        
        <h4>Get node affiliations</h4>
        
        <pre class="out callback" message="xmpp.pubsub.affiliations">
        socket.emit(
            'xmpp.pubsub.affiliations',
            {
                "to": "pubsub.evilprofessor.co.uk",
             /* "node": "xmpp-ftw updates", */
             /* "owner": true" */
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>Setting <strong>owner</strong to true allows the user to 
        get a list of all node affiliations provided they are the owner 
        of the node (otherwise an error is returned.</p>

        <p>A successful response will then be as follows:</p>
        
        <pre class="example">
        [
            { 
                jid: { user: "lloyd", domain: "evilprofessor.co.uk", resource: "laptop" },
                affiliation: 'owner'
           },
           {
                jid: { user: "dev-kitty-1", domain: "evilprofessor.co.uk", resource: "lap" },
                affiliation: 'member'
           }
       ]
        }
        </pre>
        
        <p>Note: I <strong>can not currently test this</strong> as Prosody 0.9 does not support it. 
        Once supported I will return and test.</p>
        
        <h4>Set node affiliation</h4>
      
        <pre class="out callback" message="xmpp.pubsub.affiliation">
        socket.emit(
            'xmpp.pubsub.affiliation',
            {
                "to": "pubsub.evilprofessor.co.uk",
                "node": "xmpp-ftw updates",
                "jid": "troll@underthebrid.ge",
                "affiliation": "outcast"
            },
            function(error, data) { console.log(error, data) }
        )
        </pre>
        
        <p>If the node is successfully created `<em>error</em>` will be <b>null</b> and 
        `<em>data</em>` will be <b>true</b>.</p>
        
        <p><b>Note:</b> Whilst specification allows user to update several affiliation 
        changes at once, only on per message is supported here. If required it can be 
        added later.</p>
        
<% include ./partials/footer %>
